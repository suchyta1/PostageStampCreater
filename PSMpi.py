#!/usr/bin/env python

import sys
import os
import numpy as np
import desdb
import copy
import Queue
import subprocess
import esutil
import pyfits
import galsim
from mpi4py import MPI

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable



"""
This is kind of cool, so you can send an email to yourself when the run finishes.
You'll notice my email in there, so if you're going to use this change the sender/reciever to yourself.
"""
def SendEmail(config):
    import smtplib
    from email.mime.text import MIMEText
    
    sender = 'eric.d.suchyta@gmail.com'
    receivers = [sender]
    msg = MIMEText( "Balrog run %s finished. \n \n--Message automatically generated by Balrog." %(config['label']) )
    msg['Subject'] = '%s completed' %(config['label'])
    msg['From'] = sender
    msg['To'] = sender
    
    obj = smtplib.SMTP('localhost')
    obj.sendmail(sender, receivers, msg.as_string())


# Find the files from the DES server we need to download
def GetFiles(bands, SheldonConfig, tiles):

    #First get all runs
    bs = []
    for i in range(len(bands)):
        if bands[i]!='det':
            bs.append(bands[i])
    runs = np.array( desdb.files.get_release_runs(SheldonConfig['release'], withbands=bs) )

    kwargs = {}
    kwargs['type'] = SheldonConfig['filetype']
    kwargs['fs'] = 'net'

    keepruns = []
    keepimages = []
    keeppsfs = []
    keeptiles = []

    # Pick out only the tiles we wanted
    for i in range(len(runs)):
        run = runs[i]
        tile = run[-12:]
        if tile in tiles:
            keeptiles.append(tile)
            keepruns.append(run)
            keepimages.append( [] )
            keeppsfs.append( [] )
            kwargs[SheldonConfig['runkey']] = run
            kwargs['tilename'] = tile

            for band in bands:
                kwargs['band'] = band
                image = desdb.files.get_url(**kwargs)
                image = image.replace('7443','')
                psf = image.replace('.fits.fz', '_psfcat.psf')
                keepimages[-1].append(image)
                keeppsfs[-1].append(psf)

    return [keepimages, keeppsfs, keeptiles]    




def Mkdir(dir):
    if not os.path.lexists(dir):
        os.makedirs(dir)

def Remove(file):
    if os.path.lexists(file):
        os.remove(file)

def SystemCall(cmd, redirect=None, kind='popen'):
    if kind=='system':
        cmd = subprocess.list2cmdline(cmd)
        os.system(cmd)
    elif kind=='popen':
        p = subprocess.Popen(cmd)
        p.wait()

def Download(indir, images, psfs, skip=False):
    useimages = []
    for file in images:
        infile = os.path.join(indir, os.path.basename(file))
        if not skip:
            Remove(infile)
            oscmd = ['wget', '-q', '--no-check-certificate', file, '-O', infile]
            SystemCall(oscmd)
        ufile = infile.replace('.fits.fz', '.fits')
        if not skip:
            Remove(ufile) 
            oscmd = ['funpack', '-O', ufile, infile]
            SystemCall(oscmd )
        useimages.append(ufile)

    usepsfs = []
    for psf in psfs:
        pfile = os.path.join(indir, os.path.basename(psf))
        if not skip:
            Remove(pfile)
            oscmd = ['wget', '-q', '--no-check-certificate', psf, '-O', pfile]
            SystemCall(oscmd)
        usepsfs.append(pfile)

    return [useimages, usepsfs]


def Pad(min, amin, amax):
    #diff = amax - amin
    diff = amax - amin + 1
    if diff < min:
        pad = min - diff

        add = pad / 2
        amin -= add
        amax += add
        if (pad % 2 == 1):
            r = np.random.rand()
            if r < 0.5:
                amin -= 1
            else:
                amax += 1
    return [amin,amax]


def EdgeBounds(shape, min, imax, amin, amax):
    if shape < min:
        if amin < min:
            amin = 1
            amax = min
        else:
            amax = imax
            amin = amax - min + 1

    return [amin, amax]


def Clip(outside, iter=1):
    clipped = np.copy(outside) 

    '''
    for i in range(iter):
        avg = np.average(clipped)
        std = np.std(clipped)
        diff = clipped - avg
        cut = (np.fabs(diff) < 3*std)
        clipped = clipped[cut]
    '''

    std = np.std(clipped)
    avg = np.average(clipped)
    while True:
        if len(clipped) < 10:
            print 'lots of clipping'
            break

        diff = clipped - avg
        cut = (np.fabs(diff) < 3*std)
        clipped = clipped[cut]

        std = np.std(clipped)
        newavg = np.average(clipped)
        #if (np.fabs(newavg - avg) <= 0.05*avg):
        #if np.fabs(newavg - avg)/avg < 0.05:
        if ((newavg - avg) <= 0.05*np.fabs(avg)) and ((newavg - avg) >= -0.05*np.fabs(avg)):
            break
        avg = newavg

    clipped_std = np.std(clipped)
    vmin = -clipped_std
    vmax = 5 * clipped_std
    return vmin, vmax


def PlotPostageStamps(tile, files, outdir, pos, layout, bands, imext, min, extra, maxratio=2):
    odir = os.path.join(outdir, tile)
    if os.path.exists(odir):
        subprocess.call( ['rm', '-r', odir] )

    Mkdir(odir)
    outpdf = os.path.join(outdir, '%s.pdf'%tile)

    ifiles = []
    for i in range(len(pos)):
        xmin = int(pos[i][0])
        xmax = int(pos[i][1])
        xmin, xmax = Pad(min, xmin, xmax)

        ymin = int(pos[i][2])
        ymax = int(pos[i][3])
        ymin, ymax = Pad(min, ymin, ymax)

        minx = min
        miny = min
        xdiff = xmax - xmin + 1
        ydiff = ymax - ymin + 1
        while float(xdiff)/ydiff > maxratio:
            ymin -= 1
            ymax += 1
            miny += 2
            ydiff = ymax - ymin + 1
        while float(ydiff)/xdiff > maxratio:
            xmin -= 1
            xmax += 1
            minx += 2
            xdiff = xmax - xmin + 1


        fig = plt.figure(i, figsize=(12,6))
        for j in range(len(files)):
            img = galsim.fits.read(files[j], hdu=imext)
            SubBounds = galsim.BoundsI(xmin, xmax, ymin, ymax)
            area = img[SubBounds].array

            yBounds = EdgeBounds(area.shape[0], minx, img.array.shape[0], ymin, ymax)
            xBounds = EdgeBounds(area.shape[1], miny, img.array.shape[1], xmin, xmax)
            SubBounds = galsim.BoundsI(xBounds[0], xBounds[1], yBounds[0], yBounds[1])
            area = img[SubBounds].array

            outside = area[0:2, :].flatten()
            remain = area[2:, :]
            outside = np.append(outside, remain[-2:, :].flatten())
            remain = remain[:-2, :]
            outside = np.append(outside, remain[:, 0:2].flatten())
            remain = remain[:, 2:]
            outside = np.append(outside, area[:, -2:].flatten())
            remain = remain[:, :-2]
            vmin, vmax = Clip(outside, iter=2)

            #area = pyfits.open(files[j])[0].data[xmin:xmax, ymin:ymax]
            ax = fig.add_subplot(layout[0], layout[1], j+1)
            #cax = ax.imshow(area, origin='lower', cmap=plt.get_cmap('gray'), aspect='auto', vmin=vmin, vmax=vmax)
            cax = ax.imshow(area, origin='lower', cmap=plt.get_cmap('gray'), vmin=vmin, vmax=vmax)
            divider = make_axes_locatable(ax)
            d = divider.append_axes("right", size="5%", pad=0.05)
            cbar = fig.colorbar(cax, cax=d)
        
            if len(extra[i][j]) > 0:
                px = extra[i][j][:,0] - xBounds[0]
                py = extra[i][j][:,1] - yBounds[0]
                ax.scatter( px, py, alpha=0.35, s=10, facecolors='none', edgecolors='red')

            xaxis_max = xBounds[1]-xBounds[0]+1
            yaxis_max = yBounds[1]-yBounds[0]+1
            xticks = np.arange(0, xaxis_max, 50)
            yticks = np.arange(0, yaxis_max, 50)
            ax.xaxis.set_ticks(xticks)
            ax.yaxis.set_ticks(yticks)
            ax.set_xlim( [0, xaxis_max] )
            ax.set_ylim( [0, yaxis_max] )
            title = r'%s' %(bands[j])
            ax.set_title(title, fontsize=12)

        fig.suptitle(r'%s: Bounds = (%i:%i, %i:%i)' %(tile, xBounds[0],xBounds[1], yBounds[0],yBounds[1]), fontsize=12 )
        plt.tight_layout()
        plt.subplots_adjust(top=0.9)

        file = os.path.join(odir, '%i.pdf' %i) 
        ifiles.append(file)
        plt.savefig(file, format='pdf')
        plt.close(fig)

    gs = ['gs', '-dBATCH', '-dNOPAUSE', '-q', '-sDEVICE=pdfwrite', '-sOutputFile=%s'%(outpdf)] 
    for pdf in ifiles:
        gs.append(pdf)
    cmd = subprocess.list2cmdline(gs)
    os.system(cmd)
    subprocess.call( ['rm', '-r', odir] )

    #return outpdf


def Clean(*args):
    for arg in args:
        for file in arg:
            os.remove(file)


def ServeProcesses(queue):

    done = 0
    size = queue.qsize()
    while done < size:
        rank_recv = MPI.COMM_WORLD.recv(source=MPI.ANY_SOURCE)
        job = queue.get() 
        MPI.COMM_WORLD.send(job, dest=rank_recv)
        done += 1
    for i in range(MPI.COMM_WORLD.size-1):
        MPI.COMM_WORLD.send(['shutdown',None], dest=(i+1))

def DoProcesses(imgdir, layout, outdir, bands, imext, min):

    rank = MPI.COMM_WORLD.Get_rank()
    while True:
        job = MPI.COMM_WORLD.sendrecv(rank, dest=0, source=0)
        
        if job[0] == 'shutdown':
            break

        tile, images, psfs, pos, extra = job
        imdir = os.path.join(imgdir, tile)
        Mkdir(imdir)
        images, psfs = Download(imdir , images, psfs, skip=False)
        PlotPostageStamps(tile, images, outdir, pos, layout, bands, imext, min, extra) 
        Clean(images, psfs)


def BlankExtra(cc, bands):
    c = []
    for band in bands:
        c.append([])
    cc.append(c)
    return cc


def GetCoords(rdata, edata, tiles, images, psfs, bands, xmin='xmin_image', xmax='xmax_image', ymin='ymin_image', ymax='ymax_image', tilename='tilename', ps_index='index', extra_index='index', extra=None):
    pos = Queue.Queue(len(tiles))
    for i in range(len(tiles)):
        tilecut = (rdata[tilename]==tiles[i])
        size = np.sum(tilecut)
        p = np.empty( (size,4) )
        p[:,0] = rdata[tilecut][xmin]
        p[:,1] = rdata[tilecut][xmax]
        p[:,2] = rdata[tilecut][ymin]
        p[:,3] = rdata[tilecut][ymax]

        #cc = [ [ [] ] * len(bands) ] * size
        cc = []
        for s in range(size):
            if extra==None:
                cc = BlankExtra(cc, bands)
                continue

            ind = rdata[tilecut][ps_index][s]
            ecut = (edata[extra_index]==ind)
            esize = np.sum(ecut)
            if esize==0:
                cc = BlankExtra(cc, bands)
                continue

            c = []
            for j in range(len(bands)):
                ccc = np.empty( (esize,2) )
                ccc[:,0] = edata[ecut][extra[j][0]]
                ccc[:,1] = edata[ecut][extra[j][1]]
                c.append(ccc)
            cc.append(c)
        pos.put( [tiles[i],images[i],psfs[i],p,cc] )
    return pos


def CatPDFs(outdir, outname, tiles):
    outfile = os.path.join(outdir, outname)
    gs = ['gs', '-dBATCH', '-dNOPAUSE', '-q', '-sDEVICE=pdfwrite', '-sOutputFile=%s'%(outfile)] 
    for tile in tiles:
        pdf = os.path.join(outdir, '%s.pdf'%tile)
        gs.append(pdf)
    subprocess.call(gs)


if __name__ == "__main__":

    #retrievefile = 'badRegionCutoutCoords-g.fits' 
    #retrievefile = 'get-postage-stamp.fits'
    #retrievefile = 'get-postage-stamp2.fits'
    #extracoordsfile = 'coords2.fits'
    retrievefile = 'badRegionCutoutCoords-g-noEli.fits'

    bands = ['det', 'g', 'r', 'i', 'z', 'Y']
    #extra = [ ['x','y'] ] * len(bands)
    extra = None

    layout = (2, 3)
    min = 51

    tilename = 'tilename'
    xmin = 'xmin_image'
    xmax = 'xmax_image'
    ymin = 'ymin_image'
    ymax = 'ymax_image'
    ps_index = 'index'
    extra_index = 'index'


    imgdir = '/data/esuchyta/postage-stamps'
    outdir = 'test3-postage-stamps'
    imext = 0
    #outname = '-combined.pdf'

 
    desdbConfig = {
        'release': 'sva1_coadd',
        'filetype': 'coadd_image',
        'runkey': 'coadd_run',
    }


    # Call desdb to find the tiles we need to download and delete any existing DB tables which are the same as your run label.
    if MPI.COMM_WORLD.Get_rank()==0:
        retrievedata = esutil.io.read(retrievefile)[0:20]
        if extra==None:
            extradata = None 
        else:
            extradata = esutil.io.read(extracoordsfile)
        tiles = np.unique(retrievedata[tilename])
        images, psfs, tiles = GetFiles(bands, desdbConfig, tiles)
        PostageStamps = GetCoords(retrievedata, extradata, tiles, images, psfs, bands, xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, tilename=tilename, ps_index=ps_index, extra_index=extra_index, extra=extra)
        ServeProcesses(PostageStamps)
    else:
        DoProcesses(imgdir, layout, outdir, bands, imext, min) 

    '''
    MPI.COMM_WORLD.barrier()
    if MPI.COMM_WORLD.Get_rank()==0:
        CatPDFs(outdir, outname, tiles)
    '''


    '''
    retrievedata = esutil.io.read(retrievefile)
    tiles = np.unique(retrievedata[tilename])

    images, psfs, tiles = GetFiles(bands, desdbConfig, tiles)
    PostageStamps = GetCoords(retrievedata, tiles, images, psfs, bands, xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, cx=cx, cy=cy, tilename=tilename, nocentroids=nocentroids)

    for i in range(PostageStamps.qsize()):
        PostageStamp = PostageStamps.get()

        tile, images, psfs, pos = PostageStamp
        imdir = os.path.join(imgdir, tile)
        Mkdir(imdir)
        images, psfs = Download(imdir , images, psfs, skip=False)
        PlotPostageStamps(tile, images, outdir, pos, layout, bands, imext, min, nocentroids=nocentroids) 
        Clean(images, psfs)

    CatPDFs(outdir, outname, tiles)
    '''
